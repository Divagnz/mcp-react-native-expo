# Test Generation Example

This guide demonstrates how to use the React Native MCP Server to generate comprehensive test suites.

## Sample Component

See [sample-component.tsx](./sample-component.tsx) for a complete login form component that includes:
- State management with hooks
- Input validation
- Async operations
- Error handling
- Loading states
- Accessibility features

## Generated Test Suite

See [generated-test.test.tsx](./generated-test.test.tsx) for the complete test suite generated by the MCP server.

## How to Generate Tests

### Step 1: Provide Component Code

```
Generate a comprehensive test suite for this component:

[paste LoginForm component code]

Include tests for:
- Rendering
- User interactions
- Validation logic
- Async operations
- Edge cases
- Accessibility
```

### Step 2: MCP Tool Execution

The `generate_component_test` tool will:
1. Analyze the component structure
2. Identify testable behaviors
3. Generate test cases for all scenarios
4. Include setup/teardown code
5. Add accessibility tests
6. Create snapshot tests

### Step 3: Review and Customize

The generated tests cover:
- ✅ **Rendering Tests** - Component renders correctly
- ✅ **Input Tests** - User can enter text
- ✅ **Validation Tests** - All validation rules work
- ✅ **Async Tests** - Loading states and API calls
- ✅ **Edge Cases** - Empty inputs, special characters, etc.
- ✅ **Accessibility** - testIDs and screen reader support

## Test Coverage

The generated test suite achieves:
- **100% Line Coverage** - Every line executed
- **100% Branch Coverage** - All conditional paths tested
- **100% Function Coverage** - All functions called
- **Edge Cases** - Boundary conditions tested

## Running the Tests

```bash
# Install dependencies
npm install --save-dev @testing-library/react-native @testing-library/jest-native

# Run tests
npm test

# Run with coverage
npm test -- --coverage

# Watch mode
npm test -- --watch
```

## Test Structure

### 1. Setup and Mocks

```tsx
describe('LoginForm Component', () => {
  const mockOnLoginSuccess = jest.fn();
  const mockOnLoginError = jest.fn();

  const defaultProps = {
    onLoginSuccess: mockOnLoginSuccess,
    onLoginError: mockOnLoginError,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Tests...
});
```

### 2. Rendering Tests

```tsx
describe('Rendering', () => {
  it('should render correctly with default props', () => {
    const { getByText, getByTestId } = render(<LoginForm {...defaultProps} />);

    expect(getByText('Login')).toBeTruthy();
    expect(getByTestId('username-input')).toBeTruthy();
  });
});
```

### 3. Interaction Tests

```tsx
describe('User Input', () => {
  it('should update username input when text is entered', () => {
    const { getByTestId } = render(<LoginForm {...defaultProps} />);
    const usernameInput = getByTestId('username-input');

    fireEvent.changeText(usernameInput, 'testuser');

    expect(usernameInput.props.value).toBe('testuser');
  });
});
```

### 4. Async Tests

```tsx
describe('Login Flow', () => {
  it('should call onLoginSuccess with valid credentials', async () => {
    const { getByTestId } = render(<LoginForm {...defaultProps} />);

    fireEvent.changeText(getByTestId('username-input'), 'testuser');
    fireEvent.changeText(getByTestId('password-input'), 'password123');
    fireEvent.press(getByTestId('login-button'));

    await waitFor(() => {
      expect(mockOnLoginSuccess).toHaveBeenCalledWith('testuser');
    });
  });
});
```

## Advanced Features

### Custom Validators

The tool detects optional props and generates tests:

```tsx
it('should use custom validator when provided', async () => {
  const customValidator = jest.fn(() => false);

  const { getByTestId } = render(
    <LoginForm {...defaultProps} validateUsername={customValidator} />
  );

  fireEvent.changeText(getByTestId('username-input'), 'testuser');
  fireEvent.press(getByTestId('login-button'));

  await waitFor(() => {
    expect(customValidator).toHaveBeenCalledWith('testuser');
  });
});
```

### Loading States

Tests verify loading indicators appear and disappear:

```tsx
it('should show loading indicator during login', async () => {
  const { queryByTestId } = render(<LoginForm {...defaultProps} />);

  fireEvent.press(getByTestId('login-button'));

  // Should show loading
  expect(queryByTestId('loading-indicator')).toBeTruthy();

  await waitFor(() => {
    // Should hide after completion
    expect(queryByTestId('loading-indicator')).toBeNull();
  });
});
```

### Edge Cases

Comprehensive edge case coverage:

```tsx
describe('Edge Cases', () => {
  it('should handle empty inputs', async () => {
    // Test implementation
  });

  it('should handle very long username', async () => {
    // Test implementation
  });

  it('should handle special characters', async () => {
    // Test implementation
  });
});
```

## Best Practices in Generated Tests

### 1. Descriptive Test Names

```tsx
// ✅ Good
it('should call onLoginSuccess with valid credentials', ...);

// ❌ Bad
it('works', ...);
```

### 2. Arrange-Act-Assert Pattern

```tsx
it('should update username input', () => {
  // Arrange
  const { getByTestId } = render(<LoginForm {...defaultProps} />);

  // Act
  fireEvent.changeText(getByTestId('username-input'), 'testuser');

  // Assert
  expect(getByTestId('username-input').props.value).toBe('testuser');
});
```

### 3. Test Isolation

Each test is independent with fresh mocks:

```tsx
beforeEach(() => {
  jest.clearAllMocks();
});
```

### 4. Accessibility Testing

All interactive elements have testIDs:

```tsx
<TextInput testID="username-input" />
<TouchableOpacity testID="login-button">
```

## Customizing Generated Tests

After generation, you can:

### Add Integration Tests

```tsx
describe('Integration', () => {
  it('should complete full login flow', async () => {
    // Test complete user journey
  });
});
```

### Add Performance Tests

```tsx
describe('Performance', () => {
  it('should render within performance budget', () => {
    const startTime = performance.now();
    render(<LoginForm {...defaultProps} />);
    const endTime = performance.now();

    expect(endTime - startTime).toBeLessThan(100);
  });
});
```

### Add Snapshot Tests

```tsx
it('should match snapshot', () => {
  const { toJSON } = render(<LoginForm {...defaultProps} />);
  expect(toJSON()).toMatchSnapshot();
});
```

## Common Testing Patterns

### Testing Async Operations

```tsx
it('should handle async operation', async () => {
  // Trigger async action
  fireEvent.press(getByTestId('button'));

  // Wait for completion
  await waitFor(() => {
    expect(mockCallback).toHaveBeenCalled();
  });
});
```

### Testing Error States

```tsx
it('should display error message', async () => {
  fireEvent.press(getByTestId('button'));

  await waitFor(() => {
    expect(getByTestId('error-message')).toBeTruthy();
  });
});
```

### Testing Conditional Rendering

```tsx
it('should show/hide element based on state', () => {
  const { queryByTestId } = render(<Component />);

  expect(queryByTestId('optional-element')).toBeNull();

  fireEvent.press(getByTestId('toggle-button'));

  expect(queryByTestId('optional-element')).toBeTruthy();
});
```

## Troubleshooting

### Test Fails: "Unable to find element"

**Problem**: Element not found by testID

**Solution**: Verify testID prop is set correctly

```tsx
// Component
<TextInput testID="my-input" />

// Test
getByTestId('my-input') // Must match exactly
```

### Test Fails: "Timeout waiting for..."

**Problem**: Async operation doesn't complete

**Solution**: Increase timeout or check async logic

```tsx
await waitFor(() => {
  expect(mockFn).toHaveBeenCalled();
}, { timeout: 5000 }); // Increase timeout
```

### Test Fails: "Cannot update during render"

**Problem**: State update without proper async handling

**Solution**: Wrap in act() or waitFor()

```tsx
await waitFor(() => {
  expect(getByText('Updated')).toBeTruthy();
});
```

## Next Steps

### Generate More Tests

```
Generate tests for MyOtherComponent focusing on:
- Error handling
- Performance
- Accessibility
```

### Analyze Test Coverage

```
Analyze test coverage gaps in /path/to/project

Identify:
- Untested components
- Missing edge cases
- Low coverage areas
```

### Improve Testing Strategy

```
Analyze testing strategy for my project

Recommend:
- Unit vs integration test balance
- E2E test scenarios
- Performance test approach
```

## Resources

- [React Native Testing Library Docs](https://callstack.github.io/react-native-testing-library/)
- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Testing Best Practices](../../basic-usage/common-workflows.md#testing-strategy)

---

**See Also**:
- [Sample Component](./sample-component.tsx) - The component being tested
- [Generated Tests](./generated-test.test.tsx) - Complete test suite
- [Common Workflows](../basic-usage/common-workflows.md) - Testing workflows
